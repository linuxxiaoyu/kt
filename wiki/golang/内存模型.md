# 内存模型

## Happens Before

假如有两个goroutine分别为A和B，如果A比B先发生，可以说是A先行发生于B。如果A不先行发生于B，B也不先行发生于A，则A与B是并发的。

如果在并发时需要读写共享数据，会出现data race，行为将是未知的。

## 重排

在编译代码时，CPU和编译器会利用指令重排等优化手段，它只能保证在本goroutine内的结果是正确的。如果存在多goroutine共享数据的情况，可能会发生错误。

## 缓存一致性

由于CPU的速度明显高于内存，为了提高加载速度，在CPU与内存之间会有L1、L2、L3级缓存。这些缓存中L1级缓存最靠近CPU，其速度最快，但容量也最小。CPU获取数据时，会先去缓存中查找，如果缓存中没有，才会去内存中查找。

现代的多核CPU中，L1和L2级缓存通常会集成到CPU的每个Core中，而所有Core通常共享同一个L3缓存。

为了提高执行效率，数据最先会保存在当前Core的L1缓存中，并不会立马刷新到内存中。例如Core1将数据A修改完后，会将数据A保存在Core1的L1缓存中；Core2如果想获取数据A，会依次去L1、L2、L3级缓存中查找；如果都没找到的话，才会去内存中查找；因为Core1的L1缓存中保存的数据还没刷新到内存中，Core2获取到的数据A将会是一个错误值。产生了缓存不一致的问题。

为了解决缓存不一致的问题，引入了MSI、MESI等缓存一致性协议。

TODO：MSI协议，MESI协议

## 



为了保证多个goroutine程序的正确执行，防止data race，需要使用sync包、sync.atomic包、chan等同步原语。

