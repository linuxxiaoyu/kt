## 物理内存

实际的RAM硬件。



## 虚拟内存

每个程序在执行时，操作系统为其分配的内存，是虚拟出来的。

CPU中的PC寄存器指向了下一条执行的指令。PC寄存器的位数通常大于外部地址线的位数，导致了CPU其余寻址空间的浪费。为了充分利用寻址空间，就要将内存的空间与CPU寻址空间保持一致。但通常物理内存容量会小于CPU寻址空间。

为此，操作系统欺骗每一个程序说，我的内存你都能用，管够。但其实操作系统并没有为其分配实际的物理内存，而是维护了一个虚拟内存地址到物理内存地址的映射表。当程序需要内存时，会通过这张表找到对应的物理地址。



## 页

虚拟内存被分成了很多大小相等的空间，被称为页。大小通常为4K。



## 页框

物理内存中用来存放页的空间，大小与页相等。



## 页表

保存有页 -> 页框的映射关系的结构。

在页表中，将不同的虚拟页映射到同一个物理页框，可以很方便的进行页的共享。

分页后， 内存地址可以分为高位段和低位段，高位段保存页或页框，低位段保存页或页框内的偏移量。



## 多级页表

程序运行时，其页表也会存放在内存中。如果程序的虚拟空间很大，会需要使用很多页表，消耗大量内存。使用多级页表，可以将页表进行分页存储。



## 请页

当试图访问一个虚存页时，如果虚拟地址不在页表中，说明该虚存页还没有载入内存，这时MMU会通知操作系统：发生一个页面访问错误，接下来系统会启动所谓的“请页”机制：地址无效，终止访问。地址有效，将虚存页读到空闲页框中，并更新页表。



## 快表

一组寄存器，其中保存了最近使用到的一张内存页。访问页时会先到快表中访问，不匹配的话才会去页表中查找对应的页框。



## MMU

内存管理单元，用于将虚拟地址转换为实际的物理内存地址的硬件。

通过将内存地址高位段的页码转换为页框码，加上原来地址中的地位段计算出物理地址。



## 交换分区

请页成功后，内存中没有空闲的物理页框时，系统会启动交换机制：在物理页框中寻找一个当前不再使用或近期可能不会用到的页框(LRU算法)，将其中的页移出，并装载新的页面。如果移出的页面未修改，则删除，否则写回磁盘的交换分区中。

交换分区在磁盘上，读写比内存要慢得多。只有在物理内存满时，才会使用交换分区。

交换分区可以禁用掉，但强烈不建议这么做。一旦物理内存用尽，交换分区可用空间又不足时，系统会产生一场，并随机杀掉一些进程，可能会导致严重的BUG。



## LRU算法

为了公平的选择将要被系统抛弃的页面，Linux系统使用最近最少使用（LRU）页面的衰老算法。

这种策略根据系统中每个页面被访问的频率，为物理页框中的页面设置一个叫做年龄的属性。页面被访问的次数越多，则页面的年龄越小；反之，则越大。而年龄较大的页面就是待换出页面的最佳候选者。





参考：https://blog.csdn.net/qq_38410730/article/details/81036768